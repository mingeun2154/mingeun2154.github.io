[ { "title": "baduk 프로젝트 - 2주차", "url": "/posts/baduk-2nd-week/", "categories": "Project, baduk", "tags": "Swing, baduk", "date": "2022-03-12 21:34:00 +0900", "snippet": "3.3부터 3.12까지 진행된 내용이다.새로운 기능 추가사용자가 클릭한 위치에 돌을 놓는 기능을 추가하였다. 돌을 놓는 행위를 바둑에서는 ‘착수’ 라고 한다.abstraction아래의 사진은 component들의 호출 과정이다. 그림에서는 생략되었지만 마지막으로 controller가 repaint()를 실행하여 domain의 변화를 view에 반영한다.underlying details CheckerBoardController (controller) 클릭된 위치는 크기가 interval×interval인 정사각형 구역 단위로 인식된다. 예를 들어 위치가 (46,131)인 점이 클릭되었다면3행 7열의 구역이 클릭된 것으로 인식한다. 이 행과 열은 CheckerBoard가 유지하고 있는 2차원 배열의 index 값이다. CheckerBoardService (service) controller는 service를 통해 domain을 조작한다. service가 호출되는 코드들을 통해 게임의 로직이 어떻게 구현되는 지를 파악할 수 있다. CheckerBoar (domain) 바둑판의 점들을 나타내는 2차원 배열 원소의 data가 변하게 된다. representationgrid[i][j]는 바둑판의 i번째 선과 j번째 선의 교점을 의미한다. index와 선의 번호를 일치시키기 위해 20x20 배열을 선언하였다." }, { "title": "baduk 프로젝트 - 1주차", "url": "/posts/baduk-1st-week/", "categories": "Project, baduk", "tags": "Swing, baduk", "date": "2022-03-03 00:04:00 +0900", "snippet": "바둑판 프로그램을 시작한지 1주일이 지났다. 그동안 진행된 내용들이다.componentdesign 단계와 비교해서 다음과 같이 바뀌었다. View (추가됨) : Swing Container들의 집합이다. xxxScreen 클래스들은 ‘xxx화면’을 나타낸다. 예를 들어 StartScreen은 시작화면을, NewGameScreen은 시작화면에서 ‘새 게임’ 버튼을 눌렀을때 나오는 화면이다. MainFrame 클래스는 JFrame 객체이다. 최상위 컨테이너로 프로그램이 실행되는 창(window)를 의미한다. content (추가됨) : 각각의 화면을 구성하는 Swing Component들이다. 이 객체들은 view 객체들이 생성될 때 그 객체들에 add된다. TestFrame (추가됨) : 테스트를 위한 JFrame이다. 하나의 Screen만을 띄워보고 싶을 때 이 frame에 추가해서 화면에 띄운다. 새로운 화면 GUI를디자인 할때 이 클래스에 넣어서 먼저 테스트 한 뒤에 main 코드에 적용시키기 위해 만들었다.StartScreen (시작 화면)MainFrame(JFrame) &amp;lt;- StartScreen(JPanel) &amp;lt;- NewGameButton/LoadGameButton(JButton)CheckerBoard (바둑판)TestFrame(JFrame) &amp;lt;- NewGameScreen(JPanel) &amp;lt;- CheckerBoard(JPanel)고민 현재 StartScreenController는 두 버튼에 대한 클릭을 감지한다. 클릭된 버튼에 따라 그에 맞는 화면으로 전환하는 기능을 구현할 예정이다. 그런데 이와 같은 단순 화면 전환도 controller를 거쳐서 진행되어야하는지가 의문이다. 딱히 model의 data를 바꾸는 일이 아니기 때문이다. 그렇다고 view에서만 처리하기에는 사용자와 상호작용하는 것은 controller의 역할이다. controller가 클릭을 감지하고 화면을 바꾸기 위해서는 controller에서 view에게 접근이 가능해야 한다. 구체적으로 StartScreenController가 현재 띄워진 StartScreen JPanel 또는 StartScreen이 붙어있는 전체 MainFrame 객체를 가지고 있어야 한다. 프레임워크의 도움 없이 이걸 구현하는 방법은 MainFrame을 싱글톤 객체로 만드는 방법 이 유일한 것 같다. 그래야 클래스 외부에서 공통된 유일한 객체에 접근할 수 있기 때문이다." }, { "title": "JFrame의 구조", "url": "/posts/JFrame-1/", "categories": "Project, baduk", "tags": "Swing", "date": "2022-02-28 14:31:00 +0900", "snippet": "Swing은 Java에서 GUI를 구현하기 위해 JDK에서 기본적으로 제공하는 툴킷이다.Swing으로 표현하는 GUI는 다음과 같은 구조를 가진다. JFrame하나의 window(창)이다." }, { "title": "baduk 프로젝트 - 설계", "url": "/posts/baduk-design/", "categories": "Project, baduk", "tags": "JAVA, baduk", "date": "2022-02-24 15:57:00 +0900", "snippet": "Java의 Swing 라이브러리를 사용해 바둑을 연습할 수 있는 프로그램이다.핵심 기능 착수 차례 알려주기 시간 제한 뒤로가기, 앞으로 전체 내용 저장 및 불러오기Service FlowComponentsMVC 패턴을 적용하여 패키지를 다음 components로 나누었다. controller : 사용자로부터 받은 입력을 처리한다. service : domain을 조작하여 game logic 을 구현한다. repository : domain의 상태를 저장소에 저장한다. 저장소는 사용자의 pc를 사용할 예정이다. interface로 만들어 추후에 저장소를 바꿀수 있도록 한다. domain : 게임을 구성하는 요소들이다. data로 이루어지며 사용자가 조작하는 대상이다.(Model에 해당.) renderer : Model을 화면에 그린다.(View에 해당한다.)Dependencies각 component의 의존관계는 다음과 같다. service, renderer, repository는 domain을 의존관계(dependency)로 가진다.Components 구현domaindata 위주로 필드와 메소드 이름을 정의한다. stone : 바둑돌의 abstract이다. 착수의 대상이다. 바둑돌의 물리적인 크기(반지름), 색깔을 담고 있다. board : 바둑의 abstract이다. 2차원 배열 Stone [19][19] stones_positions에 바둑돌의 유무를 저장한다. clear(), erase_oneStone() 등의 메소드를 제공한다. game : 하나의 대국 전체에 대한 abstract이다. 총 걸린 시간, 놓인 돌들의 위치를 담고 있으며 저장, 불러오기 기능의 대상이다. clock : 시계의 abstract. 제한시간, 진행시간을 화면에 출력할때 사용된다. button : 다양한 버튼들의 바탕이 된다. interface vs inheritance ❓ 여러 객체들의 공통되는 성질을 정의하기 위해 interface와 상속 중 어떤 방법을 사용해야 하는 것이 좋을까? 한 번에 여려개의 객체가 필요한 상황이기 때문에 하나의 button으로부터 상속받는게 낫다고 생각했다. 생각해보니 굳이 interface를 구현할 필요는 없다. service컨트롤러에 의해 호출되며 서비스들이 호출되는 과정은 곧 게임이 실행되는 logic이 된다. Boardservice : 특정 좌표에 대해 돌의 유무를 조작한다. * setStone(), resetGame(), takeStoneBack()등의 메소드를 지원한다. 각각 착수, 처음부터 시작하기, 한수 물리기에 해당한다. ButtonService: IsPushed()를 통해 버튼이 눌려졌는지 확인한다. 눌러졌다면 해당 버튼의 기능을 실행한다.(Domain을 조작한다.)controller사용자의 입력을 감지하고 적절한 service를 이용해 Domain을 조작한다. BoardController : click을 감지하여 최종적으로 그 자리에 돌이 출력되도록 만든다." }, { "title": "MVC Pattern", "url": "/posts/MVC/", "categories": "WEB", "tags": "mvc pattern", "date": "2022-02-24 15:20:00 +0900", "snippet": "MVC(Model View Controll)은 프로그램을 설계하는 방식 중 하나이다.MVC 패턴은 프로그램의 구성요소를 Model, View, Controller 세 가지로 구분한다.사용자의 입력을 controller에서 받아 Model을 조작하고, Model의 조작된 data를 바탕으로 View는 사용자에게 결과를 출력한다.하나하나의 구성 요소들마다 하는 일이 명확하게 분리되기 때문에 코드의 유지, 보수가 간편해진다.웹 페이지 소스를 HTML, CSS, JavaScript 세 가지로 분리한 것과 유사하다. HTML은 정보(Model)만을, CSS는 눈에 보이는 시각적 요소(View)를, JavaScript는 사용자와의 상호작용 및 HTML, CSS 조작(Controller)을 담당한다.Model 사용자가 조작하는 대상이다. view, controller 코드들로부터 완전히 분리되어야 한다. controller가 사용자 입력에 대응할 수 있도록 자기 자신의 data를 조작 할 수 있는 메서드를 지원해야 한다.View Model의 data를 화면에 시각적으로 표현한다. 필요할 때 호출되어 data를 화면에 그리기만 할 뿐, Model의 data를 저장하지 않는다.Controller 사용자로부터 받은 입력에 대응하여 Model을 조작하고 View를 사용한다. Model, View를 가지고 있어야 한다.(의존성을 주입받아야 한다)" }, { "title": "DOM", "url": "/posts/DOM/", "categories": "WEB", "tags": "web", "date": "2022-02-24 14:22:00 +0900", "snippet": "DOM이란 HTML, XML 문서를 객체로 나타내는 API 이다.API(Application Programming Interface)특정 방식으로 명령 또는 요청을 받았을 때 그에 따른 기능을 수행하도록 만들어 놓는 것을 의미한다. 함수로 비유하자면 함수의 parameter의 data type, 개수와 그에 따른 반환값을 정해놓은 주문서라고 할 수 있다. 하나의 API가 주어지면 함수의 몸통은 구현하는 프로그래머마다 다를 수 있겠지만 사용자 입장에서는 몸통이 다르다는 것을 느끼면 안된다.동일한 API를 구현했다면 구현되는 과정은 달라도 하는 일은 모두 동일하다.DOM(Document Object Model)다시 DOM으로 돌아와서, 좀더 자세히 알아보도록 하자.DOM은 html 문서의 element들을 object로 나타내는 API이다.html elements를 실제 DOM 객체로 구현하는 것은 web browser이다.좀더 자세히 말하자면 web browser의 rendering engine이다.이렇게 만들어진 객체 하나하나를 Node라고 한다" }, { "title": "Floyd Warshall 최단경로 알고리즘", "url": "/posts/floyd-warshall/", "categories": "algorithm, 최단경로", "tags": "floyd warhall", "date": "2022-02-22 17:41:00 +0900", "snippet": "Floyd Warshall 최단경로 알고리즘은 모든 노드에서부터 모든 노드까지의 최단경로를 계산한다.시간 복잡도 : O(V³)노드의 개수가 10³보다 커지면 연산 속도가 매우 느려진다(10초 이상)알고리즘 작동 방식graph[i][j]=c : i번 노드에서 j번 노드까지의 거리가 c 라는 의미이다.for k가 1부터 n까지 반복: for i가 1부터 n까지 반복: for j가 1부터 n까지 반복: i노드에서 j노드까지의 최단거리는 min(i에서 j까지의 거리, i에서 k를 거쳐 j까지 가는 거리)실선과 점선으로 표현된 경로의 비용을 비교하여 더 작은 값을 선택한다.코드import sysinput=sys.readline.inputINF=int(1e9)# 노드, 간선 개수 입력n,m=map(int, input().split())# graph 초기화graph=[[INF]*(n+1) for _ in range(n+1)]for i in range(1, n+1): graph[i][i]=0# 모든 간선 정보 입력for _ in range(m): a,b,c=map(int,input().split()) graph[a][b]=c# 알고리즘for k in range(1, n+1): for i in range(1, n+1): for j in range(1, n+1): graph[i][j]=min(graph[i][k]+graph[k][j], graph[i][j])# 결과 출력for i in range(1,n+1): for j in range(1,n+1): if graph[i][j]==INF: print(&quot;INFINITY&quot;, end=&#39; &#39;) else: print(graph[i][j], end=&#39; &#39;) print()" }, { "title": "Dijkstra 최단경로 알고리즘 O(E㏒V)", "url": "/posts/dijkstra-priority-queue/", "categories": "algorithm, 최단경로", "tags": "dijkstra, priority queue", "date": "2022-02-22 16:53:00 +0900", "snippet": "__우선순위 큐(priority queue)__를 이용하여 dijkstra 최단경로 알고리즘을 구현할 수 있다시간 복잡도 : O(E㏒V) E는 간선(edge)의 개수, V는 정점(vertex)의 개수이다. 시간복잡도에서 log의 밑(logarithm base)는 2이다.이 알고리즘에서는 시간 복잡도가 O(V)인 get_smallest_node() 대신 시간복잡도가 O(㏒)인 우선순위 큐를 사용한다.알고리즘 작동 방식while 큐가 빌때까지 반복: 큐에서 최단경로 값이 가장 작은 노드를 꺼낸다 꺼낸 노드가 이미 계산된 노드인지 확인 처리되었다면 continue for 현재 노드의 모든 인접노드에 대해 반복 현재노드에서부터 인접노드까지의 거리 갱신 갱신된 인접노드는 큐에 삽입코드import sysimport heapqinput=sys.stdin.readlineINF=int(1e9)# 노드, 간선의 개수 입력n, m=map(int, input().split())# 시작 노드 입력start=int(input())# graph, distance 초기화graph=[[] for _ in range(n+1)]distance=[INF]*(n+1)# 모든 간선의 정보 입력for _ in range(m): a,b,c=map(int, input().split()) graph[a].append((b,c))# 알고리즘def dijkstra(start): q=[] # 시작노드에 대해 초기화 distance[start]=0 for i in graph[start]: distance[i[0]]=i[1] # 우선순위 큐에 ( 시작노드에서부터 집어넣는 노드까지의 거리, 노드 번호) 튜플 삽입 heapq.heappush(q, (0, start)) # 큐가 비어있지 않은 동안 반복 for q: # 큐에서 최단거리 값이 가장 작은 노드 하나를 꺼낸다. dist, now=heapq.heappop(q) # 뽑은 노드가 이미 처리된 노드인지 확인 if distance[now]&amp;lt;dist: continue # now에서부터 인접 노드까지의 거리 갱신 for i in graph[now]: cost=distance[now]+i[1] if distance[i[0]]&amp;gt;cost: distance[i[0]]=cost heapq.heappush(q, (cost, i[0])) dijkstra(start) # 결과 출력 for i in range(1, n+1): if distance[i]==INF: print(&quot;INFINITY&quot;) else: print(distance[i])" }, { "title": "Dijkstra 최단경로 알고리즘 O(N²)", "url": "/posts/dijkstra/", "categories": "algorithm, 최단경로", "tags": "dijkstra", "date": "2022-02-22 15:32:00 +0900", "snippet": "dijkstra 최단경로 알고리즘은 하나의 시작노드에서부터 다른 모든 노드까지 의 최단경로를 구하는 알고리즘이다.시간 복잡도 : O(V²)V는 노드(vertex)의 개수이다. 알고리즘에 따라 달라질 수 있겠지만 일반적으로 괄호 안의 값이 10⁸(1억)일때 1초가 걸린다.알고리즘 작동 방식for n-1번(시작 노드를 제외한 나머지 노드의 수) 반복: 최단경로 리스트(distance)에서 값이 가장 작은 노드(now)를 뽑는다. now를 방문 처리 for now에 인접한 모든 노드(graph[i[0]])에 대해 반복: now에서 graph[i[0]]까지의 거리를 갱신 n-1번 반복하는 각각의 단계에서 시간복잡도가 O(V)인 get_smallest_node()를 호출하기 때문에 전체 코드의 시간복잡도는 O(V²)이 된다.코드import sysinput=sys.stdin.readlineINF=int(1e9)# 노드,간선의 개수 입력n,m=map(int, input().split())# 시작 노드 입력start=int(input())# graph, distance, visited 초기화graph=[[] for _ in range(n+1)] distance=[INF]*(n+1) visited=[False]*(n+1) # 모든 간선의 정보 입력for _ in range(m): a,b,c=map(int, input().split()) graph[a].append((b,c))# 최단경로가 가장 짧은 노드의 번호를 반환하는 함수def get_smallest_node(): min_value=INF index=0 # 반복문 for i in range(1,n): # 방문하지 않았던 노드 i까지의 거리가 더 짧다면 min_value 갱신 if distance[i]&amp;lt;min_value and not visited[i]: min_value=distance[i] index=i return index# dijkstra 알고리즘def dijkstra(start) # 시작 노드에 대해 초기화 visited[start]=True distance[start]=0 # 시작 노드를 제외한 나머지 노드들에 대해 n-1번 반복 for _ in range(n): # 시작 노드로부터 최단거리가 가장 짧은 노드를 하나 선택 now=get_smallest_node() visited[now]=True # 현재 노드(now)에서부터 인접 노드까지의 거리를 갱신 for i in graph[now]: cost=distance[now]+i[1] if distance[i[0]]&amp;gt;cost: distance[i[0]]=costdijkstra(start)# 결과 출력for i in range(1,n+1): if distance[i]==INF: print(&quot;INFINITY&quot;) else: print(distance[i])" }, { "title": "멀티부팅 환경에서 블루투스 키보드 연결하기", "url": "/posts/bluetooth-keyboard/", "categories": "개발환경", "tags": "bluetooth, keyboard", "date": "2022-02-15 22:34:00 +0900", "snippet": "듀얼부팅 환경에서 블루투스 키보드를 연결하는 방법은 다음과 같다. Ubuntu에서 먼저 키보드와 PC를 연결 Windows에서 키보드와 PC를 연결 2-1. [PSTools][https://download.sysinternals.com/files/PSTools.zip]를 다운 2-2. cmd를 관리자 권한으로 실행한 뒤 PSTools 가 설치된 경로로 이동 2-3. cd C:\\Users\\유저이름\\Downloads\\PSTools 로 이동(한글인 부분은 사람마다 다르다) 2-4. psexec -s -i regedit 입력 2-5. Computer-&amp;gt;HKEY_LOCAL_MACHINE-&amp;gt;SYSTEM-&amp;gt;CurrentControlSet-&amp;gt;Services-&amp;gt;BTHPORT-&amp;gt;Parameters-&amp;gt;Keys 로 들어간다 2-6. 레지스트리 편집기의 왼쪽화면에 연결된 기기의 맥주소(이름)와 페어링 키(데이터) 가 나온다2-7. 내가 연결한 키보드의 맥주소에 해당하는 페어링 키 값을 메모한다 Ubuntu로 로그인3-1. 터미널을 열고 sudo su로 사용자를 바꾼다 3-2. cd /var/lib/bluetooth/블루투스 어댑터 맥주소/키보드 맥 주소 3-3. vim info 3-4. [LinkKey]의 Key 변수에 아까 메모한 값을 대입한다 Key=키보드의 페어링 키 위 과정은 윈도우와 키보드, 우분투와 키보드 사이의 페어링 키 값을 통일시키는 과정이다." }, { "title": "Message Queue", "url": "/posts/MessageQueue/", "categories": "system programming, chattingProgram, 개념정리", "tags": "system software, message queue, IPC, c, chattingProgram", "date": "2022-01-10 00:00:00 +0900", "snippet": "채팅 프로그램을 만들기 위한 메세지 큐 연습. 개발환경 : m1 mac Editor : vscode1. server메세지 큐를 통해 받은 정보를 계산해서 client에게 전달한다.2. client메세지 큐를 통해 server에게 데이터를 전달하고 연산 결과를 받는다.3. 코드자세한 코드는 여기에4. what is message queue?5. 실행화면🚨 client를 먼저 실행해야한다 " }, { "title": "RFsender", "url": "/posts/RFsender/", "categories": "Arduino", "tags": "Arduino, IoT, RF", "date": "2021-12-31 00:00:00 +0900", "snippet": "RF를 이용하여 통신하는 리모컨 개발환경 : m1 mac IDE : vscode의 PLATFORMIO1. 라이브러리 추가pio lib install &quot;nrf24/RF24&quot;#include &amp;lt;SPI.h&amp;gt;#include &amp;lt;RF24.h&amp;gt;#include &amp;lt;nRF24L01.h&amp;gt;2.회로 구성🚨SPI 통신🚨이것때문에 계속 안되서 3일을 헤맸다… 보드에 문제가 있는줄 알고 새로 주문했는데^^ SPI 통신을 하는 모듈은 사용하는 핀이 정해져있다. SPI 통신에 대해서는 다른 포스팅에서 다루도록 하자. 결론만 설명하자면 모듈 아두이노 MOSI D11 MISO D12 SCK D13 SS D10 이렇게 연결되어야 한다.3. 코드//Sender#include &amp;lt;Arduino.h&amp;gt;#include &amp;lt;SPI.h&amp;gt;#include &amp;lt;RF24.h&amp;gt;#include &amp;lt;nRF24L01.h&amp;gt;//RF moduleRF24 radio(9,10);const byte address[6]=&quot;00001&quot;; //Address value must be same in sender and receivervoid setup() { Serial.begin(9600); radio.begin(); //RF module radio.openWritingPipe(address); //Set where to send data. radio.setPALevel(RF24_PA_MIN); //Set powerlevel. radio.stopListening(); //Set this module as sender.}void loop() { const char msg[]=&quot;hello world&quot;; Serial.println(&quot;before send&quot;); radio.write(&amp;amp;msg, sizeof(msg)); Serial.println(msg); delay(1000);}3-1. 코드 설명IPC 중 FIFO 와 사용방법이 유사하다. void openWritingPipe(const uint8_t* address); writing을 위한 pipe를 1개 open한다. address를 통해 전송할 data의 목적지를 결정한다. data를 수신받으려면 sender와 receiver의 pipe address가 같아야 한다." }, { "title": "RFreceiver", "url": "/posts/RFreceiver/", "categories": "Arduino", "tags": "Arduino, IoT, RF", "date": "2021-12-31 00:00:00 +0900", "snippet": "RF를 이용하여 통신하는 receiver 개발환경 : m1 mac IDE : vscode의 PLATFORMIO1. 라이브러리 추가pio lib install &quot;nrf24/RF24&quot;pio lib install &quot;arduino-libraries/Servo@^1.1.8&quot;#include &amp;lt;SPI.h&amp;gt;#include &amp;lt;RF24.h&amp;gt;#include &amp;lt;nRF24L01.h&amp;gt;#include &amp;lt;Servo.h&amp;gt;2.회로 구성🚨SPI 통신🚨이것때문에 계속 안되서 3일을 헤맸다… 보드에 문제가 있는줄 알고 새로 주문했는데^^ SPI 통신을 하는 모듈은 사용하는 핀이 정해져있다. SPI 통신에 대해서는 다른 포스팅에서 다루도록 하자. 결론만 설명하자면 모듈 아두이노 MOSI D11 MISO D12 SCK D13 SS D10 이렇게 연결되어야 한다.3. 코드//Receiver#include &amp;lt;Arduino.h&amp;gt;#include &amp;lt;SPI.h&amp;gt;#include &amp;lt;RF24.h&amp;gt;#include &amp;lt;nRF24L01.h&amp;gt;RF24 radio(9, 10);int led_pin=3;const byte address[6]=&quot;00001&quot;; //Address value must be same in sender and receivervoid setup() { Serial.begin(9600); radio.begin(); //RF radio.openReadingPipe(0, address); radio.setPALevel(RF24_PA_MIN); radio.startListening(); //Set this module as receiver.}void loop() { if(radio.available()){ char text[32]=&quot;empty&quot;; Serial.print(&quot;Before: &quot;); Serial.println(text); radio.read(text, sizeof(text)); Serial.print(&quot;After: &quot;); Serial.println(text); delay(1000); } else{ Serial.println(&quot;nothing received&quot;); delay(1000); }}3-1. 코드 설명IPC 중 FIFO 와 사용방법이 유사하다. void openReadingPipe(const uint8_t* address); reading을 위한 pipe를 1개 open한다. data를 수신받으려면 sender와 receiver의 pipe address가 같아야 한다.3. 결과" }, { "title": "적외선 송신기(IRsender)", "url": "/posts/IRsender/", "categories": "Arduino", "tags": "Arduino, IoT, IRremote", "date": "2021-12-31 00:00:00 +0900", "snippet": "앞서 만든 수신기에 신호를 보낼 리모컨이다. 개발환경 : m1 mac IDE : vscode의 PLATFORMIO1.회로 구성 준비물 : 아두이노 nano, 미니 브레드보드, 아두이노 적외선 레이저 모듈적외선 레이저 모듈 pinmap (출처: 에듀이노) Circuit design 버튼을 누르면 적외선 신호가 레이저의 형태로 출력된다. 2. 코드//remote controller#include &amp;lt;Arduino.h&amp;gt;#include &amp;lt;IRremote.h&amp;gt;int sendPin=3;int buttonPin=10;//turn on main lightIRsend irsend_main_on;IRData irdata_main_on{LG, 0x88, 0xC005, 0, 0x1C, 0x80, 0x88C051, nullptr};//turn off main lightIRsend main_off;IRData irdata_main_off;void setup() { Serial.begin(9600); pinMode(buttonPin, INPUT); //IRSend set irsend_main_on.begin(sendPin, false); irsend_main_on.write(&amp;amp;irdata_main_on); irsend_main_on.enableIROut(38);}void loop() { if(digitalRead(buttonPin)==HIGH){ irsend_main_on.sendLG(irdata_main_on.address, irdata_main_on.command, 0); Serial.print(&quot;turn on\\n&quot;); delay(500); }}2-1. 코드 설명IRSend 객체 발신기의 abstractsendLG(…) 함수 argument로 받은 정보를 LG protocol로 encoding하여 정보를 전송한다.3. 실행 (시리얼 모니터에 출력된 숫자들은 모두 16진수) 88C0051이 수신되면 정상적으로 수신된 경우이고 그 외의 값들은 비정상적인 경우이다.dalay() 가 없으면 의도한 값을 수신받지 못한다.4. 한계 위와같이 레이저가 수신기에 맞아야한다. 이 모듈을 사용해서 리모컨을 만들기에는 적합하지 않다." }, { "title": "적외선 수신기(IRreceiver)", "url": "/posts/IRreceiver/", "categories": "Arduino", "tags": "Arduino, IoT, IRremote", "date": "2021-12-29 00:00:00 +0900", "snippet": "아두이노를 이용하여 전등 스위치를 끄고 켤 수 있는 장치를 만들기로 했다. 개발환경 : m1 mac IDE : vscode의 PLATFORMIO1. #include &amp;#60;IRremote.h &amp;#62;라이브러리를 추가하는데에는 두 가지 방법이 있다.1-1. cli에서 명령어 입력PIO의 내장된 terminal에 다음과 같은 명령어를 입력한다.pio lib install &quot;z3t0/IRremote@^3.5.1&quot;그리고 workspace를 업데이트하기 위해 새 창을 띄워 해당 프로젝트를 다시 연다. main.cpp 에서 include 한다.1-2. 직접 lib 폴더에 추가원하는 라이브러리를 다운받아 프로젝트의 라이브러리에 추가 한다.2. 회로 구성 준비물 : 아두이노uno, 브레드보드, Arduino IR SensorArduino IR Sensor pinmap (출처: 에듀이노) Circuit design 3. 코드//receiver#include &amp;lt;Arduino.h&amp;gt;#include &amp;lt;IRremote.h&amp;gt;int recvPin = 2;IRrecv irrecv;IRData* irdata;void setup() { irrecv.begin(recvPin, true); Serial.begin(9600);}void manufacturer(IRData* irdata){ switch (irdata-&amp;gt;protocol){ case SAMSUNG: Serial.print(&quot;SAMSUNG&quot;); break; case LG: Serial.print(&quot;LG &quot;); break; default: Serial.print(&quot;DEFAULT&quot;); break; }}void command(IRData* irdata){ manufacturer(irdata); Serial.print(&#39;\\t&#39;); Serial.print(&quot;\\t address: &quot;); Serial.print(irdata-&amp;gt;address, HEX); Serial.print(&quot;\\t command: &quot;); Serial.print(irdata-&amp;gt;command, HEX); Serial.print(&quot;\\t extra: &quot;); Serial.print(irdata-&amp;gt;extra, HEX); Serial.print(&quot;\\t numberOfBits: &quot;); Serial.print(irdata-&amp;gt;numberOfBits, HEX); Serial.print(&quot;\\t flags: &quot;); Serial.print(irdata-&amp;gt;flags, HEX); Serial.print(&quot;\\t decodedRawData: &quot;); Serial.print(irdata-&amp;gt;decodedRawData, HEX);}void loop() { if(irrecv.decode()){ irdata=irrecv.read(); if(irdata-&amp;gt;flags==0x40){ Serial.print(&quot;OverFlowed\\n&quot;); return ; } // manufacturer(irdata); // Serial.print(&#39;\\t&#39;); command(irdata); Serial.print(&#39;\\n&#39;); irrecv.resume(); } irdata=nullptr;}3-1. 코드 설명IRrecv 객체 수신기의 abstract이다.IRData 구조체 적외선 신호의 abstract이다.void manufacturer(IRData* irdata); 이 함수는__ IRData.protocol __ 을 조사하여 제조사를 알려준다. 제조사별로 data를 encoding하는 protocol이 다르다. 위의 코드에서는 삼성과 LG만 구별하고 나머지는 DEFAULT로 나타냈다.4. 실행만든 IR receiver를 이용하여 집에있던 리모컨들의 신호를 분석해보았다. (출력되는 숫자들은 전부 16진수)4-1. Btv 리모컨4-2. WHISEN 리모컨" }, { "title": "shared memory", "url": "/posts/sharedMemory/", "categories": "system programming, 개념정리", "tags": "system V IPC, shared memory", "date": "2021-11-29 21:57:00 +0900", "snippet": "Inter-Process Communication (IPC)ipc란 프로세스 사이의 통신을 의미한다.ipc에는 pipe, fifo, message queue, shared memory, semaphore 가 있다. 이 중에서 message queue, shared memory, semaphore 를 묶어서 systme V ipc 라고도 한다.process &amp;amp; memory managementOS는 virtual memory 라는 개념을 통해 하나의 프로세스가 무한대의 memory를 사용하는 것처럼 느끼도록 해준다. 사용자는 os에 의해 제공되는 virtual memory 에만 접근할 수 있으며 실제 프로세스가 저장되어있는 physical address 에는 절대 접근할 수 없다. 또한 서로 다른 프로세스는 절대 서로의 memory 공간에 접근할 수 없다.shared memory특정 프로세스들이 RAM을 공유하는 방식이다. 공유되는 구역을 segment라고 한다.How to use it1. IPC KEY#include &amp;lt;sys/ipc.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;key_t ftok(const char* path, int proj_id);system V ipc 에서 사용할 key를 생성한다. path: key를 생성할 경로 또는 이름 proj_id: 같은 경로 내에서 key를 구별하기 위한 값(0~255 사이의 값을 사용한다) return value: 성공하면 key, 실패하면 -1example: key_t key=ftok(&quot;abc&quot;, &#39;A&#39;);2. creating shared memory#include &amp;lt;sys/sem.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;int shmget(key_t key, size_t size, int shmflg);segment 생성key: 시스템 전체에서 유효하다. segment를 다른 segment와 구별해준다. size: segment의 크기를 결정한다. shmflg: IPC_CREAT, IPC_EXCL retrun value: local identifier (file descriptor와 비슷한 개념이다) 🚨 전체 system에서 local id가 같은 segment는 존재할 수 있지만 key value가 같은 segment는 존재할 수 없다.example: int shmid=shmget(key, 512, 0600|IPC_CREAT);3. attach생성된 segment를 프로세스에 연결한다.#include &amp;lt;sys/shm.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;void* shmat(int shmid, const void* shmaddr, int shmflg);shmid: segment id shmaddr: segment를 연결할 주소. 보통 NULL(kernel이 알아서 결정한다) shmflg: 보통 0 return value: 성공하면 연결된 segment의 시작 주소, 실패하면 -1example: int* shmaddr=shmat(shmid, NULL, 0);4. detatch연결되었던 segment를 프로세스로부터 분리한다.#include &amp;lt;sys/shm.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;int shmdt(const void* shmaddr);shmaddr: segment주소return value: 성공하면 0, 실패하면 -1 🚨 detatch한다고 segment가 삭제되는 것이 아니다5. removedynamic variable, open()된 file들은 프로세스가 종료되면 OS에 의해 자동으로 청소된다. 하지만 ipc resource는 자동적으로 지워지지 않는다.5-1. 터미널에서 제거ipcrm -m [shmid]5-2. program 내부에서 삭제#include &amp;lt;sys/mhm.h&amp;gt;int shmctl(int shmid, int cmd, struct shm_ds* buf);cmd: IPC_RMID, IPC_SET, IPC_STAT buf: 보통 NULL" }, { "title": "Contributing to Chromium", "url": "/posts/contributing-chromium/", "categories": "chromium, study", "tags": "chromium, commands", "date": "2021-11-24 09:04:00 +0900", "snippet": "더 자세한 내용은 여기로1. creating a change$ git checkout -b mychange -t origin/main change를 위한 브랜치 생성. origin/main을 upstream으로 설정2. commit checklist rebase your repository $ git pull &amp;amp;&amp;amp; gclient sync -D 작업 안하고 rebase만 하는 main branch에서 실행 build $ autoninja -C out/Default Chrome formatting codes$ git cl format 더 자세한 내용 3. commit your change locally in git$ git commit -a -a : 수정되거나 삭제된 파일들을 자동으로 staging한다. 새로 생성된 파일은 직접 add해야 한다.4. upload the CL to Gerrit$ git cl upload5. find file owners$ git cl owners cs.chromium 에서 직접 OWNERS 파일을 열어 확인할 수도 있다.6. go to the Gerrit$ git cl webRun Chromium$ out/Default/chrome" }, { "title": "첫 번째 게시글", "url": "/posts/first-posting/", "categories": "blogging", "tags": "first post", "date": "2021-11-24 00:30:00 +0900", "snippet": "드디어 첫 번째 게시글이다!" } ]
